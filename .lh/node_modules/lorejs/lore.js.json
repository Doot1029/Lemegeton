{
    "sourceFile": "node_modules/lorejs/lore.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1772046992959,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1772048945187,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -512,9 +512,9 @@\n         } else if (tag === 'dungeon_font' || tag === 'df') {\n           result += '<span style=\"font-family: \\'DungeonFont\\', sans-serif\">';\n         } else if (tag === 'dungeon_mode' || tag === 'dm') {\n           result += '<span style=\"font-family: \\'dungeon mode\\', sans-serif\">';\n-        } else if (tag === 'dungeon_mode_inverted' || tag === 'dmi') {\n+        } else if (tag === 'play' || tag === 'dmi') {\n           result += '<span style=\"font-family: \\'dungeon mode inverted\\', sans-serif\">';\n         }\n       } else {\n         if (tag === 'font_reset' || tag === 'fr') {\n"
                },
                {
                    "date": 1772048952336,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -512,9 +512,9 @@\n         } else if (tag === 'dungeon_font' || tag === 'df') {\n           result += '<span style=\"font-family: \\'DungeonFont\\', sans-serif\">';\n         } else if (tag === 'dungeon_mode' || tag === 'dm') {\n           result += '<span style=\"font-family: \\'dungeon mode\\', sans-serif\">';\n-        } else if (tag === 'play re' || tag === 'dmi') {\n+        } else if (tag === 'play regular' || tag === 'dmi') {\n           result += '<span style=\"font-family: \\'dungeon mode inverted\\', sans-serif\">';\n         }\n       } else {\n         if (tag === 'font_reset' || tag === 'fr') {\n"
                },
                {
                    "date": 1772048960229,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -512,9 +512,9 @@\n         } else if (tag === 'dungeon_font' || tag === 'df') {\n           result += '<span style=\"font-family: \\'DungeonFont\\', sans-serif\">';\n         } else if (tag === 'dungeon_mode' || tag === 'dm') {\n           result += '<span style=\"font-family: \\'dungeon mode\\', sans-serif\">';\n-        } else if (tag === 'play regular' || tag === 'dmi') {\n+        } else if (tag === 'play regular' || tag === 'pr') {\n           result += '<span style=\"font-family: \\'dungeon mode inverted\\', sans-serif\">';\n         }\n       } else {\n         if (tag === 'font_reset' || tag === 'fr') {\n"
                }
            ],
            "date": 1772046992959,
            "name": "Commit-0",
            "content": "/**\n* Copyright 2025 RetoraDev\n*\n*   Licensed under the Apache License, Version 2.0 (the \"License\");\n*   you may not use this file except in compliance with the License.\n*   You may obtain a copy of the License at\n*\n*       http://www.apache.org/licenses/LICENSE-2.0\n*\n*   Unless required by applicable law or agreed to in writing, software\n*   distributed under the License is distributed on an \"AS IS\" BASIS,\n*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n*   See the License for the specific language governing permissions and\n*   limitations under the License.\n*/\n\n(function (global, factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    module.exports = factory();\n  } else {\n    global.LORE = factory();\n  }\n})(typeof window !== \"undefined\" ? window : this, function () {\n  \"use strict\";\n\n  // ANSI color codes and style constants for Node.js\n  const ANSI_COLORS = {\n    black: \"\\x1b[30m\",\n    red: \"\\x1b[31m\",\n    green: \"\\x1b[32m\",\n    yellow: \"\\x1b[33m\",\n    blue: \"\\x1b[34m\",\n    magenta: \"\\x1b[35m\",\n    cyan: \"\\x1b[36m\",\n    white: \"\\x1b[37m\",\n    reset: \"\\x1b[0m\"\n  };\n  const ANSI_STYLES = {\n    reset: \"\\x1b[0m\",\n    bold: \"\\x1b[1m\",\n    thick: \"\\x1b[1m\",\n    strong: \"\\x1b[1m\",\n    b: \"\\x1b[1m\",\n    italic: \"\\x1b[3m\",\n    cursive: \"\\x1b[3m\",\n    i: \"\\x1b[3m\",\n    underline: \"\\x1b[4m\",\n    u: \"\\x1b[4m\",\n    blink: \"\\x1b[5m\",\n    inverse: \"\\x1b[7m\",\n    hidden: \"\\x1b[8m\"\n  };\n\n  // Constants\n  const VERSION = \"1.0.3\";\n  const STORAGE_KEY = \"lore_save_data\";\n  const DEFAULT_PROMPT = \"> \";\n  const DEFAULT_THEME = {\n    \"--lore-bg-color\": \"#000000\",\n    \"--lore-text-color\": \"#ffffff\",\n    \"--lore-prompt-color\": \"#00ff00\",\n    \"--lore-input-color\": \"#ffffff\",\n    \"--lore-font-family\": \"monospace\",\n    \"--lore-font-size\": \"16px\",\n    \"--lore-border-color\": \"#333333\"\n  };\n  const DEFAULT_CONFIG = {\n    prompt: DEFAULT_PROMPT,\n    autosave: false,\n    typingSpeed: 30,\n    debug: false,\n    clearScreenOnNovelLoad: true,\n    disableTextAnimation: false\n  };\n\n  // Utility functions\n  const Utils = {\n    isBrowser: typeof window !== \"undefined\" && typeof document !== \"undefined\",\n    isNode: typeof process !== \"undefined\" && process.versions && process.versions.node,\n    deepClone(obj) {\n      return { ...obj };\n    },\n    uuid() {\n      return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        const r = (Math.random() * 16) | 0;\n        const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n      });\n    },\n    debounce(func, wait) {\n      let timeout;\n      return function executedFunction(...args) {\n        const later = () => {\n          clearTimeout(timeout);\n          func(...args);\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n      };\n    },\n    colorNameToHex(color) {\n      const colors = {\n        black: \"#000000\",\n        red: \"#ff0000\",\n        green: \"#00ff00\",\n        yellow: \"#ffff00\",\n        blue: \"#0000ff\",\n        magenta: \"#ff00ff\",\n        cyan: \"#00ffff\",\n        white: \"#ffffff\"\n      };\n      return colors[color.toLowerCase()] || color;\n    },\n    isValidColor(color) {\n      if (!color) return false;\n      // Check if it's a named color\n      const namedColors = [\"black\", \"red\", \"green\", \"yellow\", \"blue\", \"magenta\", \"cyan\", \"white\"];\n      if (namedColors.includes(color.toLowerCase())) return true;\n      // Check if it's a hex color\n      return /^#?([0-9A-F]{3}){1,2}$/i.test(color);\n    },\n    isURL(value) {\n      return value.startsWith(\"file://\") || value.startsWith(\"./\") || value.startsWith(\"../\") || value.startsWith(\"http://\") || value.startsWith(\"https://\");\n    },\n    deserializeFunction(func) {\n      if (typeof func === \"string\") {\n        return new Function(`const state = arguments[0]; const engine = arguments[1]; ${func}`);\n      } else {\n        return func;\n      }\n    },\n    arraysEqual(a, b) {\n      if (a === b) return true;\n      if (a == null || b == null) return false;\n      if (a.length !== b.length) return false;\n      for (let i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) return false;\n      }\n      return true;\n    },\n    async loadModule(url) {\n      try {\n        const response = await fetch(url);\n        const content = await response.text();\n        if (!response.ok) {\n          console.error(\"File at\", url, \"not found!\");\n          return {};\n        }\n        const module = new Function(`\n            const module = {\n              exports: {}\n            };\n            try {\n              ${content}\n            } catch(error) {\n              return module;\n              throw error;\n            }\n            return module;\n          `)();\n        return module.exports;\n      } catch (error) {\n        console.error(\"Error loading module from \", url, error);\n        return {};\n      }\n    }\n  };\n\n  // Core Engine Class\n  // @allow node\n  class Game {\n    constructor(options = {}) {\n      this.state = {\n        currentRoom: null,\n        inventory: [],\n        flags: {},\n        variables: {},\n        history: [],\n        gameTime: 0\n      };\n      this.config = {\n        ...DEFAULT_CONFIG,\n        ...options\n      };\n      this.world = {\n        rooms: new Map(),\n        items: new Map(),\n        characters: new Map(),\n        events: new Map(),\n        commands: new Map(),\n        aliases: new Map(),\n        keybindings: new Map()\n      };\n      this.plugins = new Map();\n      this.theme = { ...DEFAULT_THEME };\n      this.historyIndex = -1;\n      this.queueIsRunning = false;\n      this.isRunning = false;\n      this.outputQueue = [];\n      this.outputBuffer = [];\n      this.animationFrames = new Map();\n      this.animationIntervals = new Map();\n      // Completion state\n      this._completionState = null;\n      this._nodeCompletionState = null;\n      // Formatting state\n      this.formattingState = {\n        color: null,\n        bold: false,\n        italic: false,\n        underline: false\n      };\n      // Animation state\n      this.animationState = {\n        isAnimating: false,\n        currentAnimation: null\n      };\n      // Initialize based on environment\n      if (Utils.isBrowser) {\n        this.initBrowser();\n      } else if (Utils.isNode) {\n        this.initNode();\n      }\n      // Register default commands\n      this.registerDefaultCommands();\n    }\n    // Environment initialization\n    initBrowser() {\n      this.env = \"browser\";\n      // Create terminal elements\n      this.terminalElement = document.createElement(\"div\");\n      this.terminalElement.className = \"lore-terminal\";\n      this.terminalElement.style.cssText = `\n          position: fixed;\n          top: 0;\n          left: 0;\n          width: 100%;\n          height: 100%;\n          background-color: ${this.theme[\"--lore-bg-color\"]};\n          color: ${this.theme[\"--lore-text-color\"]};\n          font-family: ${this.theme[\"--lore-font-family\"]};\n          font-size: ${this.theme[\"--lore-font-size\"]};\n          overflow: auto;\n          padding: 20px;\n          box-sizing: border-box;\n        `;\n      this.outputElement = document.createElement(\"div\");\n      this.outputElement.className = \"lore-output\";\n      this.outputElement.style.cssText = `\n          height: calc(100% - 60px);\n          overflow-y: auto;\n          margin-bottom: 20px;\n          white-space: pre-wrap;\n        `;\n      this.inputContainer = document.createElement(\"div\");\n      this.inputContainer.className = \"lore-input-container\";\n      this.inputContainer.style.cssText = `\n          display: flex;\n          align-items: center;\n          background: transparent;\n        `;\n      this.promptElement = document.createElement(\"span\");\n      this.promptElement.className = \"lore-prompt\";\n      this.promptElement.textContent = this.parseFormatting(this.config.prompt);\n      this.inputElement = document.createElement(\"input\");\n      this.inputElement.className = \"lore-input\";\n      this.inputElement.type = \"text\";\n      this.inputElement.style.cssText = `\n          flex: 1;\n          background: transparent;\n          border: none;\n          outline: none;\n          color: ${this.theme[\"--lore-input-color\"]};\n          font-family: ${this.theme[\"--lore-font-family\"]};\n          font-size: ${this.theme[\"--lore-font-size\"]};\n          margin-left: 5px;\n        `;\n      // Assemble terminal\n      this.inputContainer.appendChild(this.promptElement);\n      this.inputContainer.appendChild(this.inputElement);\n      this.terminalElement.appendChild(this.outputElement);\n      this.terminalElement.appendChild(this.inputContainer);\n      // Add to document if not already present\n      if (!document.querySelector(\".lore-terminal\")) {\n        document.body.appendChild(this.terminalElement);\n        document.body.style.margin = \"0\";\n        document.body.style.padding = \"0\";\n      }\n      // Set up event listeners\n      this.setupBrowserEvents();\n    }\n    initNode() {\n      this.env = \"node\";\n      this.readline = require(\"readline\");\n      this.fs = require(\"fs\");\n      this.path = require(\"path\");\n      this.rl = this.readline.createInterface({\n        input: process.stdin,\n        output: process.stdout,\n        prompt: this.parseFormatting(this.config.prompt)\n      });\n      this.setupNodeEvents();\n    }\n    // Event setup\n    setupBrowserEvents() {\n        this.inputElement.addEventListener('keydown', (e) => {\n          if (e.key === 'Enter') {\n            if (!this.animationState.isAnimating) {\n              this.processInput(this.inputElement.value);\n              this.inputElement.value = '';\n              e.preventDefault();\n            } else {\n              this.skipAnimation();\n              e.preventDefault();\n            }\n          } else if (e.key === 'ArrowUp') {\n            this.navigateHistory(-1);\n            e.preventDefault();\n          } else if (e.key === 'ArrowDown') {\n            this.navigateHistory(1);\n            e.preventDefault();\n          } else if (e.key === 'Tab' || e.key === 'ArrowRight') {\n            this.autoComplete();\n            e.preventDefault();\n          } else if (e.key === 'Escape' && this.animationState.isAnimating) {\n            this.skipAnimation();\n            e.preventDefault();\n          }\n        });\n        // Handle window resize\n        window.addEventListener('resize', Utils.debounce(() => {\n          this.outputElement.scrollTop = this.outputElement.scrollHeight;\n        }, 250));\n        // Focus input on terminal click\n        this.terminalElement.addEventListener('click', () => {\n          this.inputElement.focus();\n        });\n        this.inputElement.addEventListener('dblclick', e => {\n          this.autoComplete();\n          e.preventDefault();\n        });\n      }\n    setupNodeEvents() {\n      this.rl.on('line', (input) => {\n        if (this.animationState.isAnimating) {\n          this.skipAnimation();\n          this.rl.prompt();\n        } else {\n          this.processInput(input);\n          this.rl.prompt();\n        }\n      }).on('close', () => {\n        process.exit(0);\n      });\n      // Handle Tab key specifically for Node.js\n      if (process.stdin.isTTY) {\n        process.stdin.setRawMode(true);\n        process.stdin.on('data', (data) => {\n          // Check if it's a Tab key (ASCII 9)\n          if (data.length === 1 && data[0] === 9) { // Tab key\n            // Get current line from readline\n            const line = this.rl.line;\n            // Use our completer\n            const [completions, completed] = this.readlineCompleter(line);\n            if (completions.length > 0 && completed !== line) {\n              // Update the readline with the completed line\n              this.rl.line = completed;\n              this.rl.cursor = completed.length;\n              this.rl._refreshLine();\n            }\n            return; // Prevent default behavior\n          }\n          // Check for Ctrl+C (SIGINT)\n          if (data.length === 1 && data[0] === 3) {\n            this.rl.emit('SIGINT');\n            return;\n          }\n        });\n      }\n      // Set up tab completion for Node\n      this.rl.on('SIGINT', () => {\n        if (this.animationState.isAnimating) {\n          this.skipAnimation();\n          this.rl.prompt();\n        } else {\n          this.rl.question('Are you sure you want to exit? (y/n) ', (answer) => {\n            if (answer.match(/^y(es)?$/i)) {\n              this.rl.close();\n            } else {\n              this.rl.prompt();\n            }\n          });\n        }\n      });\n    }\n    // Formatting parser\n    parseFormatting(text) {\n      if (this.env === 'browser') {\n        return this.parseFormattingBrowser(text);\n      } else {\n        return this.parseFormattingNode(text);\n      }\n    }\n    parseFormattingBrowser(text) {\n      const formatRegex = /\\{\\{([^}]+)\\}\\}/g;\n      let lastIndex = 0;\n      let result = '';\n      let match;\n      // Reset formatting state\n      this.formattingState = {\n        color: null,\n        bold: false,\n        italic: false,\n        underline: false\n      };\n      while ((match = formatRegex.exec(text)) !== null) {\n        // Add text before the formatting tag\n        result += text.substring(lastIndex, match.index);\n        lastIndex = match.index + match[0].length;\n        // Process the formatting tag\n        const tag = match[1].trim().toLowerCase();\n        result += this.processSingleTag(tag);\n      }\n      // Add the remaining text\n      result += text.substring(lastIndex);\n      // Close any open formatting tags\n      if (this.formattingState.underline) result += '</span>';\n      if (this.formattingState.italic) result += '</em>';\n      if (this.formattingState.bold) result += '</strong>';\n      if (this.formattingState.color) result += '</span>';\n      return result;\n    }\n    parseFormattingNode(text) {\n      const formatRegex = /\\{\\{([^}]+)\\}\\}/g;\n      let lastIndex = 0;\n      let result = '';\n      let match;\n      // Reset formatting state\n      this.formattingState = {\n        color: null,\n        bold: false,\n        italic: false,\n        underline: false\n      };\n      while ((match = formatRegex.exec(text)) !== null) {\n        // Add text before the formatting tag\n        result += text.substring(lastIndex, match.index);\n        lastIndex = match.index + match[0].length;\n        // Process the formatting tag\n        const tag = match[1].trim().toLowerCase();\n        result += this.processSingleTag(tag);\n      }\n      // Add the remaining text\n      result += text.substring(lastIndex);\n      // Reset formatting at the end\n      if (this.formattingState.color || this.formattingState.bold ||\n        this.formattingState.italic || this.formattingState.underline) {\n        result += ANSI_STYLES.reset;\n      }\n      return result;\n    }\n    processSingleTag(tag) {\n      let result = '';\n      if (this.env === 'browser') {\n        if (tag === 'font_reset' || tag === 'fr') {\n          result += '</span>';\n          this.formattingState = {\n            color: null,\n            bold: false,\n            italic: false,\n            underline: false\n          };\n        } else if (tag === 'color_reset') {\n          if (this.formattingState.color) {\n            result += '</span>';\n            this.formattingState.color = null;\n          }\n        } else if (Utils.isValidColor(tag)) {\n          // Close previous color span if exists\n          if (this.formattingState.color) {\n            result += '</span>';\n          }\n          const color = Utils.colorNameToHex(tag.replace('#', ''));\n          result += `<span style=\"color: ${color}\">`;\n          this.formattingState.color = color;\n        } else if (tag === 'bold' || tag === 'thick' || tag === 'strong' || tag === 'b') {\n          if (!this.formattingState.bold) {\n            result += '<span style=\"font-weight: bold\">';\n            this.formattingState.bold = true;\n          }\n        } else if (tag === 'italic' || tag === 'cursive' || tag === 'i') {\n          if (!this.formattingState.italic) {\n            result += '<span style=\"font-style: italic\">';\n            this.formattingState.italic = true;\n          }\n        } else if (tag === 'underline' || tag === 'u') {\n          if (!this.formattingState.underline) {\n            result += '<span style=\"text-decoration: underline\">';\n            this.formattingState.underline = true;\n          }\n        } else if (tag === 'inverse' || tag === 'inv') {\n          result += '<span style=\"font-family: \\'dungeon mode inverted\\', sans-serif\">';\n        } else if (tag === 'newline' || tag === 'n') {\n          result += '<br>';\n        } else if (tag === 'double_newline' || tag === 'dn') {\n          result += '<br><br>';\n        } else if (tag === 'tabulator' || tag === 'tab' || tag === 't') {\n          result += '&nbsp;&nbsp;&nbsp;&nbsp;';\n        } else if (tag === 'instant') {\n          // Instant tag - handled in animation, just remove the tag\n          result += '';\n        } else if (tag === 'dungeon_font' || tag === 'df') {\n          result += '<span style=\"font-family: \\'DungeonFont\\', sans-serif\">';\n        } else if (tag === 'dungeon_mode' || tag === 'dm') {\n          result += '<span style=\"font-family: \\'dungeon mode\\', sans-serif\">';\n        } else if (tag === 'dungeon_mode_inverted' || tag === 'dmi') {\n          result += '<span style=\"font-family: \\'dungeon mode inverted\\', sans-serif\">';\n        }\n      } else {\n        if (tag === 'font_reset' || tag === 'fr') {\n          result += ANSI_STYLES.reset;\n          this.formattingState = {\n            color: null,\n            bold: false,\n            italic: false,\n            underline: false\n          };\n        } else if (tag === 'color_reset') {\n          if (this.formattingState.color || this.formattingState.bold ||\n            this.formattingState.italic || this.formattingState.underline) {\n            result += ANSI_STYLES.reset;\n            this.formattingState = {\n              color: null,\n              bold: false,\n              italic: false,\n              underline: false\n            };\n          }\n        } else if (Utils.isValidColor(tag)) {\n          const colorName = tag.replace('#', '');\n          if (ANSI_COLORS[colorName]) {\n            result += ANSI_COLORS[colorName];\n            this.formattingState.color = colorName;\n          }\n        } else if (tag === 'bold' || tag === 'thick' || tag === 'strong' || tag === 'b') {\n          if (!this.formattingState.bold) {\n            result += ANSI_STYLES.bold;\n            this.formattingState.bold = true;\n          }\n        } else if (tag === 'italic' || tag === 'cursive' || tag === 'i') {\n          if (!this.formattingState.italic) {\n            result += ANSI_STYLES.italic;\n            this.formattingState.italic = true;\n          }\n        } else if (tag === 'underline' || tag === 'u') {\n          if (!this.formattingState.underline) {\n            result += ANSI_STYLES.underline;\n            this.formattingState.underline = true;\n          }\n        } else if (tag === 'newline' || tag === 'n') {\n          result += '\\n';\n        } else if (tag === 'double_newline' || tag === 'dn') {\n          result += '\\n\\n';\n        } else if (tag === 'tabulator' || tag === 'tab' || tag === 't') {\n          result += '\\t';\n        } else if (tag === 'instant') {\n          // Instant tag - handled in animation, just remove the tag\n          result += '';\n        }\n      }\n      return result;\n    }\n    // Command processing\n    processInput(input) {\n      if (!input.trim()) return;\n      // Reset completion state when command is executed\n      this._completionState = null;\n      this._nodeCompletionState = null;\n      // Interrupt any ongoing animation\n      if (this.animationState.currentAnimation || this.queueIsRunning) {\n        this.skipAnimation();\n        return;\n      }\n      // Add to history\n      this.state.history.push(input);\n      this.historyIndex = this.state.history.length;\n      // Echo input\n      if (this.env === 'browser') {\n        this.printLine(`${this.config.prompt}${input}`, true);\n      }\n      // Parse and execute command\n      const [command, ...args] = input.trim().split(/\\s+/);\n      let normalizedCommand = command.toLowerCase();\n      let commandAvailable = true;\n      // Look for command aliases otherwise mark command not available\n      if (!this.world.commands.has(normalizedCommand)) {\n        if (this.world.aliases.has(normalizedCommand)) {\n          normalizedCommand = this.world.aliases.get(normalizedCommand);\n        } else {\n          commandAvailable = false;\n        }\n      }\n      if (commandAvailable) {\n        try {\n          const command = this.world.commands.get(normalizedCommand);\n          command?.fn?.call(this, args, this);\n        } catch (error) {\n          this.printLine(`Error executing command: ${error.message}`);\n          if (this.config.debug) {\n            console.error(error);\n          }\n        }\n      } else {\n        this.printLine(`Unknown command: ${command}. Type 'help' for available commands.`);\n      }\n      // Autosave if enabled\n      if (this.config.autosave) {\n        this.saveGame('autosave', true);\n      }\n    }\n    navigateHistory(direction) {\n      if (this.state.history.length === 0) return;\n      // Reset completion state when navigating history\n      this._completionState = null;\n      this._nodeCompletionState = null;\n      this.historyIndex += direction;\n      if (this.historyIndex < 0) {\n        this.historyIndex = 0;\n      } else if (this.historyIndex >= this.state.history.length) {\n        this.historyIndex = this.state.history.length;\n        this.inputElement.value = \"\";\n        return;\n      }\n      this.inputElement.value = this.state.history[this.historyIndex];\n    }\n    autoComplete(input) {\n      if (!input) {\n        if (this.env === 'browser') {\n          input = this.inputElement.value.trim();\n        } else {\n          return; // In Node.js, readline handles completion\n        }\n      }\n      if (!input) return;\n      const inputParts = input.split(\" \");\n      const currentWord = inputParts[inputParts.length - 1].toLowerCase();\n      // Get completions using the same logic as readlineCompleter\n      const completions = this.getCompletions(currentWord, inputParts, inputParts.length);\n      // Filter matches based on current word\n      const matches = completions.filter(completion => \n        completion.toLowerCase().startsWith(currentWord.toLowerCase())\n      );\n      if (matches.length === 1) {\n        // Single match - complete it\n        inputParts[inputParts.length - 1] = matches[0];\n        if (this.env === 'browser') {\n          this.inputElement.value = inputParts.join(\" \");\n        }\n      } else if (matches.length > 1) {\n        // Multiple matches - cycle through them\n        // Store current completion state if not exists\n        if (!this._completionState) {\n          this._completionState = {\n            originalInput: input,\n            matches: matches,\n            currentIndex: -1\n          };\n        } else {\n          // If we're already cycling, increment index\n          this._completionState.currentIndex = \n            (this._completionState.currentIndex + 1) % matches.length;\n        }\n        // Get the current completion\n        const completion = matches[this._completionState.currentIndex];\n        inputParts[inputParts.length - 1] = completion;\n        if (this.env === 'browser') {\n          this.inputElement.value = inputParts.join(\" \");\n        }\n        // Reset completion state if we've cycled through all options\n        if (this._completionState.currentIndex === matches.length - 1) {\n          // Keep the state for next tab press to continue cycling\n        }\n      } else {\n        // No matches - reset completion state\n        this._completionState = null;\n      }\n    }\n    readlineCompleter(line) {\n      const input = line.trim();\n      const parts = input.split(/\\s+/);\n      const currentWord = parts[parts.length - 1] || '';\n      // Get all possible completions\n      const completions = this.getCompletions(currentWord, parts, parts.length);\n      // Filter matches based on current word\n      const hits = completions.filter(completion => \n        completion.toLowerCase().startsWith(currentWord.toLowerCase())\n      );\n      if (hits.length > 0) {\n        // Initialize or get completion state\n        if (!this._nodeCompletionState || \n            this._nodeCompletionState.originalLine !== line ||\n            !Utils.arraysEqual(this._nodeCompletionState.hits, hits)) {\n          this._nodeCompletionState = {\n            originalLine: line,\n            hits: hits,\n            currentIndex: -1\n          };\n        }\n        // Cycle to next completion\n        this._nodeCompletionState.currentIndex = \n          (this._nodeCompletionState.currentIndex + 1) % hits.length;\n        const currentCompletion = hits[this._nodeCompletionState.currentIndex];\n        // Replace the last word in the line with the completion\n        const completedLine = parts.slice(0, -1).concat(currentCompletion).join(' ');\n        // Return the completed line for readline to use\n        return [[completedLine], completedLine];\n      }\n      // No matches - return original line\n      return [[line], line];\n    }\n    getCompletions(currentWord, parts, partCount) {\n      const completions = new Set();\n      // Command completions (always available)\n      for (const [commandName, command] of this.world.commands) {\n        if (command.weight !== -1) { // Don't include hidden commands\n          completions.add(commandName);\n          if (command.aliases) {\n            command.aliases.forEach(alias => completions.add(alias));\n          }\n        }\n      }\n      // Get current room context\n      const currentRoom = this.world.rooms.get(this.state.currentRoom);\n      if (currentRoom) {\n        // Room exit completions\n        if (currentRoom.exits) {\n          Object.keys(currentRoom.exits).forEach(exit => completions.add(exit));\n        }\n        // Item completions in room\n        if (currentRoom.items) {\n          currentRoom.items.forEach(itemId => {\n            const item = this.world.items.get(itemId);\n            if (item) {\n              completions.add(item.name.toLowerCase());\n              if (item.aliases) {\n                item.aliases.forEach(alias => completions.add(alias.toLowerCase()));\n              }\n            }\n          });\n        }\n        // Character completions in room\n        if (currentRoom.characters) {\n          currentRoom.characters.forEach(charId => {\n            const character = this.world.characters.get(charId);\n            if (character) {\n              completions.add(character.name.toLowerCase());\n              if (character.aliases) {\n                character.aliases.forEach(alias => completions.add(alias.toLowerCase()));\n              }\n              // Add genre pronouns if only one character\n              if (currentRoom.characters.length === 1 && character.genre) {\n                if (character.genre === 'female') {\n                  completions.add('her');\n                  completions.add('she');\n                } else if (character.genre === 'male') {\n                  completions.add('him');\n                  completions.add('he');\n                }\n              }\n            }\n          });\n        }\n      }\n      // Inventory item completions\n      this.state.inventory.forEach(itemId => {\n        const item = this.world.items.get(itemId);\n        if (item) {\n          completions.add(item.name.toLowerCase());\n          if (item.aliases) {\n            item.aliases.forEach(alias => completions.add(alias.toLowerCase()));\n          }\n        }\n      });\n      // Topic completions for \"talk about\" commands\n      if (partCount >= 3 && parts[0] === 'talk' && currentRoom && currentRoom.characters) {\n        const characterName = parts[1].toLowerCase();\n        // Find the character\n        for (const charId of currentRoom.characters) {\n          const character = this.world.characters.get(charId);\n          if (character && (\n            character.name.toLowerCase().includes(characterName) ||\n            (character.aliases && character.aliases.some(alias => \n              alias.toLowerCase().includes(characterName))\n            )\n          )) {\n            // Add all topics for this character\n            if (character.topics) {\n              Object.keys(character.topics).forEach(topic => completions.add(topic));\n              Object.values(character.topics).forEach(topicData => {\n                if (topicData.aliases) {\n                  topicData.aliases.forEach(alias => completions.add(alias));\n                }\n              });\n            }\n            break;\n          }\n        }\n      }\n      // Direction shortcuts for \"go\" command\n      if (parts[0] === 'go' && partCount === 2) {\n        const directions = ['north', 'south', 'east', 'west', 'northeast', 'northwest', \n                           'southeast', 'southwest', 'up', 'down', 'in', 'out'];\n        const shortDirs = ['n', 's', 'e', 'w', 'ne', 'nw', 'se', 'sw', 'u', 'd', 'i', 'o'];\n        directions.forEach(dir => completions.add(dir));\n        shortDirs.forEach(dir => completions.add(dir));\n      }\n      // Save slot completions for save/load commands\n      if ((parts[0] === 'save' || parts[0] === 'load' || parts[0] === 'delete') && partCount === 2) {\n        completions.add('default');\n        completions.add('autosave');\n        completions.add('slot1');\n        completions.add('slot2');\n        completions.add('slot3');\n      }\n      return Array.from(completions).sort();\n    }\n    findCommonPrefix(strings) {\n      if (strings.length === 0) return \"\";\n      let prefix = strings[0];\n      for (let i = 1; i < strings.length; i++) {\n        while (strings[i].indexOf(prefix) !== 0) {\n          prefix = prefix.substring(0, prefix.length - 1);\n          if (prefix === \"\") return \"\";\n        }\n      }\n      return prefix;\n    }\n    processOutputQueue() {\n      if (this.outputQueue.length === 0) {\n        this.queueIsRunning = false;\n        if (this.env === \"node\") {\n          this.rl.prompt();\n        }\n        return;\n      }\n      this.queueIsRunning = true;\n      const nextItem = this.outputQueue.shift();\n      if (this.config.disableTextAnimation || nextItem.instant) {\n        if (nextItem.img) {\n          this.printImageInstantly(nextItem.text, nextItem.callback);\n        } else {\n          this.printInstantly(nextItem.text, nextItem.callback);\n        }\n      } else {\n        if (nextItem.img) {\n          this.animateImage(nextItem.text, nextItem.callback);\n          this.animationState.isAnimating = true;\n        } else {\n          this.animateText(nextItem.text, nextItem.callback);\n          this.animationState.isAnimating = true;\n        }\n      }\n    }\n    // Output methods\n    print(text, instant = false, img = false) {\n      return new Promise((resolve, reject) => {\n        this.outputQueue.push({\n          text,\n          instant,\n          img,\n          callback: () => resolve()\n        });\n        // Start loop if paused\n        if (!this.queueIsRunning) {\n          this.processOutputQueue();\n        }\n      });\n    }\n    printLine(text = '', instant = false) {\n      return this.print(text + (this.env === 'browser' ? '{{instant}}<br>{{/instant}}' : '\\n'), instant);\n    }\n    printImg(text, instant = false) {\n      return this.print(text, instant, true);\n    }\n    clearScreen() {\n      if (this.env === \"browser\") {\n        this.outputElement.innerHTML = \"\";\n      } else {\n        process.stdout.write(\"\\x1B[2J\\x1B[0f\");\n      }\n    }\n    animateText(text, callback) {\n      let index = 0;\n      let instantMode = false;\n      let outputText = '';\n      let tagStack = [];\n      if (this.env === 'browser') {\n        const div = document.createElement('div');\n        this.outputElement.appendChild(div);\n        this.animationState.currentAnimation = setInterval(() => {\n          if (index >= text.length) {\n            clearInterval(this.animationState.currentAnimation);\n            this.animationState.currentAnimation = null;\n            this.animationState.isAnimating = false;\n            if (callback) callback();\n            this.processOutputQueue();\n            return;\n          }\n          // Check for opening instant tag\n          if (text.substring(index, index + 11) === '{{instant}}') {\n            instantMode = true;\n            index += 11;\n            tagStack.push('instant');\n            return;\n          }\n          // Check for closing instant tag\n          if (text.substring(index, index + 13) === '{{/instant}}') {\n            if (tagStack[tagStack.length - 1] === 'instant') {\n              tagStack.pop();\n              instantMode = tagStack.includes('instant');\n            }\n            index += 13;\n            return;\n          }\n          // Check for other formatting tags\n          if (text.charAt(index) === '{' && text.charAt(index + 1) === '{') {\n            const tagEnd = text.indexOf('}}', index);\n            if (tagEnd !== -1) {\n              const tag = text.substring(index + 2, tagEnd).trim().toLowerCase();\n              // Handle formatting tags\n              outputText += this.processSingleTag(tag);\n              index = tagEnd + 2;\n              div.innerHTML = outputText;\n              return;\n            }\n          }\n          if (instantMode) {\n            // Find the next closing instant tag or end of text\n            const closingIndex = text.indexOf('{{/instant}}', index);\n            if (closingIndex === -1) {\n              // No closing tag found, add all remaining text\n              outputText += text.substring(index);\n              div.innerHTML = outputText;\n              index = text.length;\n            } else {\n              // Add text until closing tag\n              outputText += text.substring(index, closingIndex);\n              div.innerHTML = outputText;\n              index = closingIndex;\n            }\n          } else {\n            outputText += text.charAt(index);\n            div.innerHTML = outputText;\n            index++;\n          }\n          this.outputElement.scrollTop = this.outputElement.scrollHeight;\n        }, this.config.typingSpeed);\n      } else {\n        this.animationState.currentAnimation = setInterval(() => {\n          if (index >= text.length) {\n            clearInterval(this.animationState.currentAnimation);\n            this.animationState.currentAnimation = null;\n            this.animationState.isAnimating = false;\n            if (callback) callback();\n            this.processOutputQueue();\n            return;\n          }\n          // Check for opening instant tag\n          if (text.substring(index, index + 11) === '{{instant}}') {\n            instantMode = true;\n            index += 11;\n            tagStack.push('instant');\n            return;\n          }\n          // Check for closing instant tag\n          if (text.substring(index, index + 13) === '{{/instant}}') {\n            if (tagStack[tagStack.length - 1] === 'instant') {\n              tagStack.pop();\n              instantMode = tagStack.includes('instant');\n            }\n            index += 13;\n            return;\n          }\n          // Check for other formatting tags\n          if (text.charAt(index) === '{' && text.charAt(index + 1) === '{') {\n            const tagEnd = text.indexOf('}}', index);\n            if (tagEnd !== -1) {\n              const tag = text.substring(index + 2, tagEnd).trim().toLowerCase();\n              // Handle formatting tags\n              process.stdout.write(this.processSingleTag(tag));\n              index = tagEnd + 2;\n              return;\n            }\n          }\n          if (instantMode) {\n            // Find the next closing instant tag or end of text\n            const closingIndex = text.indexOf('{{/instant}}', index);\n            if (closingIndex === -1) {\n              // No closing tag found, add all remaining text\n              process.stdout.write(text.substring(index));\n              index = text.length;\n            } else {\n              // Add text until closing tag\n              process.stdout.write(text.substring(index, closingIndex));\n              index = closingIndex;\n            }\n          } else {\n            process.stdout.write(text.charAt(index));\n            index++;\n          }\n        }, this.config.typingSpeed);\n      }\n    }\n    printInstantly(text, callback, processQueue = true) {\n      const formattedText = this.parseFormatting(text);\n      if (this.env === 'browser') {\n        const div = document.createElement('div');\n        div.innerHTML = formattedText;\n        this.outputElement.appendChild(div);\n        this.outputElement.scrollTop = this.outputElement.scrollHeight;\n      } else {\n        process.stdout.write(formattedText);\n      }\n      callback && callback();\n      processQueue && this.processOutputQueue();\n    }\n    updateLastLine(text) {\n      if (this.env === 'browser') {\n        const lines = this.outputElement.querySelectorAll('div');\n        if (lines.length > 0) {\n          const lastLine = lines[lines.length - 1];\n          lastLine.innerHTML = this.parseFormatting(text);\n        } else {\n          this.print(text, true);\n        }\n      } else {\n        // Move cursor up one line and clear line\n        process.stdout.write('\\x1B[1A\\x1B[2K');\n        process.stdout.write(this.parseFormatting(text) + '\\n');\n      }\n    }\n    printTextLineByLine(text, callback) {\n      const lines = text.split('\\n');\n      let index = 0;\n      const printNextLine = () => {\n        if (index >= lines.length) {\n          callback && callback();\n        } else {\n          const newLine = this.env == \"node\" ? \"\\n\" : \"\";\n          this.printInstantly(\n            lines[index] + newLine,\n            () => setTimeout(() => printNextLine(), this.config.typingSpeed),\n            false\n          );\n        }\n        index++;\n      };\n      printNextLine();\n    }\n    animateImage(text, callback) {\n      const isAnimation = Array.isArray(text);\n      const firstFrame = isAnimation ? text[0] : text;\n      const animationFrames = isAnimation ? text : [text];\n      if (this.env === 'browser') {\n        const animationId = Utils.uuid();\n        // Print the first frame\n        this.printTextLineByLine(firstFrame, () => {\n          if (!isAnimation) {\n            // Single image, not an animation\n            callback && callback();\n            this.animationState.isAnimating = false;\n            this.processOutputQueue();\n            return;\n          }\n          // Animation setup\n          let currentFrame = 0;\n          let animationLines = firstFrame.split('\\n');\n          const totalLines = animationLines.length;\n          // Store animation state\n          this.animationFrames.set(animationId, {\n            frames: animationFrames,\n            currentFrame: 0,\n            totalLines: totalLines,\n            elementIds: [],\n            callback: callback\n          });\n          // Track which DOM elements belong to this animation\n          const outputLines = this.outputElement.querySelectorAll('div');\n          const startIndex = Math.max(0, outputLines.length - totalLines);\n          for (let i = startIndex; i < outputLines.length; i++) {\n            outputLines[i].classList.add(`lore-animation-${animationId}`);\n            this.animationFrames.get(animationId).elementIds.push(i);\n          }\n          // Start animation loop\n          const animate = () => {\n            currentFrame = (currentFrame + 1) % animationFrames.length;\n            this.updateAnimation(animationId, currentFrame);\n            this.animationFrames.get(animationId).currentFrame = currentFrame;\n          };\n          // Start animation interval\n          const intervalId = setInterval(animate, 200); // 5 FPS by default\n          this.animationIntervals.set(animationId, intervalId);\n          // Store callback to call when animation should stop\n          this.animationFrames.get(animationId).callback = callback;\n          // Continue queue\n          this.processOutputQueue();\n        });\n      } else {\n        this.printTextLineByLine(firstFrame, () => this.processOutputQueue());\n      }\n    }\n    printImageInstantly(text, callback) {\n      const isAnimation = Array.isArray(text);\n      const firstFrame = isAnimation ? text[0] : text;\n      const newLine = this.env == \"node\" ? \"\\n\" : \"\";\n      this.printInstantly(newLine + firstFrame + newLine, () => this.processOutputQueue());\n    }\n    updateAnimation(animationId, frameIndex) {\n      if (!this.animationFrames.has(animationId)) return;\n      const animation = this.animationFrames.get(animationId);\n      const frame = animation.frames[frameIndex];\n      const frameLines = frame.split('\\n');\n      // Get all elements that are part of this animation\n      const elements = this.outputElement.querySelectorAll(`.lore-animation-${animationId}`);\n      // Update each line\n      for (let i = 0; i < Math.min(elements.length, frameLines.length); i++) {\n        elements[i].textContent = frameLines[i];\n      }\n      // If the new frame has more lines, add them\n      if (frameLines.length > elements.length) {\n        for (let i = elements.length; i < frameLines.length; i++) {\n          const newElement = document.createElement('div');\n          newElement.textContent = frameLines[i];\n          newElement.classList.add(`lore-animation-${animationId}`);\n          this.outputElement.appendChild(newElement);\n          animation.elementIds.push(-1); // Mark as new element\n        }\n      }\n      // If the new frame has fewer lines, hide the extra ones\n      for (let i = frameLines.length; i < elements.length; i++) {\n        elements[i].textContent = '';\n      }\n    }\n    stopAnimation(animationId) {\n      if (this.animationIntervals.has(animationId)) {\n        clearInterval(this.animationIntervals.get(animationId));\n        this.animationIntervals.delete(animationId);\n      }\n      if (this.animationFrames.has(animationId)) {\n        const animation = this.animationFrames.get(animationId);\n        // Call the callback if it exists\n        if (animation.callback) {\n          animation.callback();\n        }\n        this.animationFrames.delete(animationId);\n      }\n    }\n    skipAnimation() {\n      // Handle text animations\n      if (this.animationState.currentAnimation && this.animationState.isAnimating) {\n        clearInterval(this.animationState.currentAnimation);\n        this.animationState.currentAnimation = null;\n        this.animationState.isAnimating = false;\n        // Process all remaining animation items instantly\n        while (this.outputQueue.length > 0) {\n          const animationItem = this.outputQueue.shift();\n          const formattedText = this.parseFormatting(typeof animationItem.text == \"string\" ? animationItem.text : animationItem.text[0]);\n          if (this.env === 'browser') {\n            const div = document.createElement('div');\n            div.innerHTML = formattedText;\n            this.outputElement.appendChild(div);\n          } else {\n            process.stdout.write(formattedText);\n          }\n          if (animationItem.callback) {\n            animationItem.callback();\n          }\n        }\n      }\n      // Handle image animations\n      if (this.animationIntervals.size > 0) {\n        // Stop all image animations\n        for (const [animationId, intervalId] of this.animationIntervals.entries()) {\n          clearInterval(intervalId);\n          // Show the first frame of the animation\n          const animation = this.animationFrames.get(animationId);\n          if (animation) {\n            const firstFrame = animation.frames[0];\n            if (this.env === 'browser') {\n              // Replace animation with first frame\n              const elements = this.outputElement.querySelectorAll(`.lore-animation-${animationId}`);\n              const frameLines = firstFrame.split('\\n');\n              for (let i = 0; i < Math.min(elements.length, frameLines.length); i++) {\n                elements[i].textContent = frameLines[i];\n              }\n              // Remove any extra lines\n              for (let i = frameLines.length; i < elements.length; i++) {\n                elements[i].remove();\n              }\n            } else {\n              // In Node.js, we need to rewrite the animation area with the first frame\n              const frameLines = firstFrame.split('\\n');\n              // Move cursor up to the start of the animation\n              process.stdout.write(`\\x1B[${animation.totalLines}A`);\n              // Print the first frame\n              for (let i = 0; i < frameLines.length; i++) {\n                process.stdout.write(`\\x1B[2K${frameLines[i]}\\n`);\n              }\n              // Clear any extra lines\n              for (let i = frameLines.length; i < animation.totalLines; i++) {\n                process.stdout.write(`\\x1B[2K\\n`);\n              }\n            }\n            // Call the callback if it exists\n            if (animation.callback) {\n              animation.callback();\n            }\n          }\n        }\n        // Clear all animation state\n        this.animationIntervals.clear();\n        this.animationFrames.clear();\n      }\n      // Scroll to bottom\n      if (this.env === \"browser\") {\n        this.outputElement.scrollTop = this.outputElement.scrollHeight;\n      }\n      // Ensure animation state is reset\n      this.animationState.isAnimating = false;\n      this.queueIsRunning = false;\n    }\n    updatePrompt(newPrompt) {\n      if (this.env === \"browser\") {\n        this.config.prompt = newPrompt;\n        this.promptElement.innerHTML = this.parseFormatting(newPrompt);\n      } else {\n        this.config.prompt = newPrompt;\n        this.rl.setPrompt(this.parseFormatting(newPrompt));\n        this.rl.prompt();\n      }\n    }\n    // Game state management\n    start(startRoomId) {\n      this.startGame(this.startRoomId || this.state.currentRoom);\n    }\n    startGame(startRoomId) {\n      this.isRunning = true;\n      this.state.currentRoom = startRoomId;\n      this.look();\n      if (this.env === \"node\") {\n        this.rl.prompt();\n      } else {\n        this.inputElement.focus();\n      }\n    }\n    restartGame() {\n      this.state = {\n        currentRoom: null,\n        inventory: [],\n        flags: {},\n        variables: {},\n        history: [],\n        gameTime: 0\n      };\n      this.clearScreen();\n      this.printLine(\"Game restarted.\");\n      if (this.world.rooms.size > 0) {\n        const firstRoom = Array.from(this.world.rooms.keys())[0];\n        this.startGame(firstRoom);\n      }\n    }\n    // Room navigation\n    move(direction) {\n      const currentRoom = this.world.rooms.get(this.state.currentRoom);\n      if (!currentRoom || !currentRoom.exits || !currentRoom.exits[direction]) {\n        this.printLine(`You can't go that way.`);\n        return false;\n      }\n      const nextRoomId = currentRoom.exits[direction];\n      this.enterRoom(nextRoomId);\n      return true;\n    }\n    enterRoom(roomId) {\n      const nextRoom = this.world.rooms.get(roomId);\n      if (!nextRoom) {\n        this.printLine(`The path leads nowhere.`);\n        return false;\n      }\n      // Check if room is locked\n      if (nextRoom.condition && !nextRoom.condition(this.state)) {\n        this.printLine(nextRoom.blockedMessage || `You can't go that way right now.`);\n        return false;\n      }\n      this.state.currentRoom = nextRoom.id;\n      this.state.gameTime++;\n      // Call onEnter callback if defined\n      if (nextRoom.onEnter) {\n        nextRoom.onEnter(this.state, this);\n      }\n      this.look(true);\n      return true;\n    }\n    look(silent = false) {\n      const room = this.world.rooms.get(this.state.currentRoom);\n      if (!room) {\n        this.printLine(\"You are in the void.\");\n        return;\n      }\n      // Display room name and description\n      if (room.name && room.name.length) {\n        this.printLine(`{{dmi}}${room.name}{{fr}}`);\n        this.printLine(\"\");\n      }\n      // Display room image if available\n      if (room.image) {\n        this.printImg(room.image);\n        this.printLine(\"\");\n      }\n      if (room.description && room.description.length) {\n        this.printLine(room.description);\n        this.printLine(\"\");\n      }\n      // Call onLook\n      if (!silent && room.onLook) {\n        room.onLook(this.state, this);\n      }\n      // Display items in room\n      if (room.items && room.items.length > 0) {\n        const itemList = room.items\n          .map(id => {\n            const item = this.world.items.get(id);\n            return item ? item.name : \"unknown item\";\n          })\n          .join(\", \");\n        this.printLine(`You see: ${itemList}`);\n      }\n      // Display characters in room\n      if (room.characters && room.characters.length > 0) {\n        const charList = room.characters\n          .map(id => {\n            const character = this.world.characters.get(id);\n            return character ? character.name : \"unknown character\";\n          })\n          .join(\", \");\n        this.printLine(`You see: ${charList}`);\n      }\n      // Show tutorials\n      if (room.tutorial || room.tutorials) {\n        this.printLine(\"\");\n        if (typeof room.tutorial === \"string\") {\n          this.printTutorial(room.tutorial);\n        } else if (typeof room.tutorial === \"object\" || typeof room.tutorials === \"object\") {\n          (room.tutorial || room.tutorials).forEach(command => {\n            this.printTutorial(command);\n          });\n        }\n        if (!room.keepTutorials) {\n          delete room.tutorial;\n          delete room.tutorials;\n        }\n      }\n    }\n    printRoomExits(room) {\n      if (!room) return false;\n      if (room.exits) {\n        let exitList = \"\";\n        Object.keys(room.exits).forEach(exit => exitList += ` - ${exit}{{n}}`);\n        this.printLine(`Where would you like to go?\\n${exitList}`);\n      } else {\n        this.printLine(\"You don't see how to exit\");\n      }\n      return true;\n    }\n    printTutorial(key) {\n      const command = this.world.commands.get(key);\n      if (!command || !command.purpose) return;\n      this.printLine(`Type {{bold}}${command.name}{{font_reset}} to ${command.purpose}.`);\n    }\n    stopAnimation(animationId) {\n      if (this.animationIntervals.has(animationId)) {\n        clearInterval(this.animationIntervals.get(animationId));\n        this.animationIntervals.delete(animationId);\n      }\n      if (this.animationFrames.has(animationId)) {\n        this.animationFrames.delete(animationId);\n      }\n      // Clear the animation from output in browser\n      if (this.env === \"browser\") {\n        const elements = this.outputElement.querySelectorAll(`.lore-animation-${animationId}`);\n        elements.forEach(el => el.remove());\n      }\n    }\n    stopAllAnimations() {\n      for (const id of this.animationIntervals.keys()) {\n        this.stopAnimation(id);\n      }\n    }\n    // Room locking system\n    lockRoom(roomId, condition, blockedMessage = \"The way is blocked.\") {\n      const room = this.world.rooms.get(roomId);\n      if (room) {\n        room.condition = condition;\n        room.blockedMessage = blockedMessage;\n        return true;\n      }\n      return false;\n    }\n    unlockRoom(roomId) {\n      const room = this.world.rooms.get(roomId);\n      if (room) {\n        room.condition = null;\n        room.blockedMessage = null;\n        return true;\n      }\n      return false;\n    }\n    isRoomLocked(roomId) {\n      const room = this.world.rooms.get(roomId);\n      return room && room.condition && !room.condition(this.state);\n    }\n    // Item management and interaction\n    takeItem(itemId) {\n      const room = this.world.rooms.get(this.state.currentRoom);\n      if (!room || !room.items || !room.items.includes(itemId)) {\n        this.printLine(\"You don't see that here.\");\n        return false;\n      }\n      const item = this.world.items.get(itemId);\n      if (!item) {\n        this.printLine(\"You can't take that.\");\n        return false;\n      }\n      if (!item.takeable) {\n        this.printLine(`You can't take the ${item.shortName || item.name}.`);\n        return false;\n      }\n      // Remove from room, add to inventory\n      room.items = room.items.filter(id => id !== itemId);\n      this.state.inventory.push(itemId);\n      this.printLine(`You take the ${item.shortName || item.name}.`);\n      return true;\n    }\n    dropItem(itemId) {\n      const itemIndex = this.state.inventory.indexOf(itemId);\n      if (itemIndex === -1) {\n        this.printLine(\"You don't have that item.\");\n        return false;\n      }\n      const item = this.world.items.get(itemId);\n      if (!item) {\n        this.printLine(\"You can't drop that.\");\n        return false;\n      }\n      const room = this.world.rooms.get(this.state.currentRoom);\n      if (!room) {\n        this.printLine(\"You can't drop items here.\");\n        return false;\n      }\n      // Remove from inventory, add to room\n      this.state.inventory.splice(itemIndex, 1);\n      if (!room.items) room.items = [];\n      room.items.push(itemId);\n      this.printLine(`You drop the ${item.shortName || item.name}.`);\n      return true;\n    }\n    useItem(itemId, targetId = null) {\n      const itemIndex = this.state.inventory.indexOf(itemId);\n      if (itemIndex === -1) {\n        this.printLine(\"You don't have that item.\");\n        return false;\n      }\n      const item = this.world.items.get(itemId);\n      if (!item) {\n        this.printLine(\"You can't use that.\");\n        return false;\n      }\n      // If no target specified, use the item on itself\n      if (!targetId) {\n        if (item.use) {\n          return item.use(this.state, this);\n        } else {\n          this.printLine(`You can't use the ${item.shortName || item.name} that way.`);\n          return false;\n        }\n      }\n      // Check if target is in inventory\n      const targetInInventory = this.state.inventory.includes(targetId);\n      // Check if target is in the room\n      const room = this.world.rooms.get(this.state.currentRoom);\n      const targetInRoom = room && room.items && room.items.includes(targetId);\n      // Check if target is a character in the room\n      const targetIsCharacter = room && room.characters && room.characters.includes(targetId);\n      if (!targetInInventory && !targetInRoom && !targetIsCharacter) {\n        this.printLine(\"You don't see that here.\");\n        return false;\n      }\n      let target;\n      if (targetIsCharacter) {\n        target = this.world.characters.get(targetId);\n      } else {\n        target = this.world.items.get(targetId);\n      }\n      if (!target) {\n        this.printLine(\"You can't use that.\");\n        return false;\n      }\n      // Check if item has a specific use for this target\n      if (item.useOn && item.useOn[targetId]) {\n        return item.useOn[targetId](this.state, this);\n      }\n      // Check if target has a general use handler\n      if (target.useWith && target.useWith[itemId]) {\n        return target.useWith[itemId](this.state, this);\n      }\n      this.printLine(`Using the ${item.shortName || item.name} on the ${item.shortName || target.name} doesn't seem to do anything.`);\n      return false;\n    }\n    lookAtItem(itemName) {\n      const room = this.world.rooms.get(this.state.currentRoom);\n      if (!room || !room.items) {\n        this.printLine(\"You don't see that here.\");\n        return false;\n      }\n      // Find item by name or alias\n      let item = null;\n      for (const itemId of room.items) {\n        const currentItem = this.world.items.get(itemId);\n        if (currentItem && (\n          currentItem.name.toLowerCase().includes(itemName) ||\n          (currentItem.aliases && currentItem.aliases.some(alias => \n            alias.toLowerCase().includes(itemName))\n          )\n        )) {\n          item = currentItem;\n          break;\n        }\n      }\n      if (!item) {\n        this.printLine(\"You don't see that here.\");\n        return false;\n      }\n      if (item.look) {\n        item.look(this.state, this);\n      } else if (item.description) {\n        this.printLine(item.description);\n      } else {\n        this.printLine(`It's a ${item.shortName || item.name}.`);\n      }\n      return true;\n    }\n    useUntakeableItem(itemName) {\n      const room = this.world.rooms.get(this.state.currentRoom);\n      if (!room || !room.items) {\n        this.printLine(\"You don't see that here.\");\n        return false;\n      }\n      // Find item by name or alias\n      let item = null;\n      for (const itemId of room.items) {\n        const currentItem = this.world.items.get(itemId);\n        if (currentItem && (\n          currentItem.name.toLowerCase().includes(itemName) ||\n          (currentItem.aliases && currentItem.aliases.some(alias => \n            alias.toLowerCase().includes(itemName))\n          )\n        )) {\n          item = currentItem;\n          break;\n        }\n      }\n      if (!item) {\n        this.printLine(\"You don't see that here.\");\n        return false;\n      }\n      if (item.use) {\n        return item.use(this.state, this);\n      } else {\n        this.printLine(`You're not sure how to use the ${item.shortName || item.name}.`);\n        return false;\n      }\n    }\n    // Dialog functions\n    async confirm(prompt) {\n      if (this.env === 'browser') {\n        // Browser implementation - terminal style\n        this.printLine(prompt);\n        this.printLine('1. Yes');\n        this.printLine('2. No');\n        return new Promise((resolve) => {\n          const handleInput = (input) => {\n            const choice = input.trim().toLowerCase();\n            if (choice === '1' || choice === 'yes' || choice === 'y') {\n              resolve(true);\n            } else if (choice === '2' || choice === 'no' || choice === 'n') {\n              resolve(false);\n            } else {\n              this.updateLastLine('Please enter 1 for Yes or 2 for No: ');\n              this.inputElement.addEventListener('keydown', handleInput, { once: true });\n            }\n          };\n          this.updateLastLine('Select option (1-2): ');\n          this.inputElement.addEventListener('keydown', handleInput, { once: true });\n        });\n      } else {\n        // Node.js implementation\n        this.printLine(prompt);\n        this.printLine('1. Yes');\n        this.printLine('2. No');\n        return new Promise((resolve) => {\n          this.rl.question('Select option (1-2): ', (answer) => {\n            const choice = answer.trim().toLowerCase();\n            if (choice === '1' || choice === 'yes' || choice === 'y') {\n              resolve(true);\n            } else if (choice === '2' || choice === 'no' || choice === 'n') {\n              resolve(false);\n            } else {\n              this.printLine('Invalid selection. Please try again.');\n              resolve(this.confirm(prompt));\n            }\n          });\n        });\n      }\n    }\n    async selectFromList(prompt, options) {\n      if (this.env === 'browser') {\n        // Browser implementation - terminal style\n        this.printLine(prompt);\n        options.forEach((option, index) => {\n          this.printLine(`${index + 1}. ${option}`);\n        });\n        this.printLine(`${options.length + 1}. Cancel`);\n        return new Promise((resolve) => {\n          const handleInput = (input) => {\n            const choice = parseInt(input.trim(), 10);\n            if (!isNaN(choice) && choice >= 1 && choice <= options.length + 1) {\n              resolve(choice === options.length + 1 ? -1 : choice - 1);\n            } else {\n              this.updateLastLine(`Please enter a number between 1 and ${options.length + 1}: `);\n              this.inputElement.addEventListener('keydown', handleInput, { once: true });\n            }\n          };\n          this.updateLastLine(`Select option (1-${options.length + 1}): `);\n          this.inputElement.addEventListener('keydown', handleInput, { once: true });\n        });\n      } else {\n        // Node.js implementation\n        this.printLine(prompt);\n        options.forEach((option, index) => {\n          this.printLine(`${index + 1}. ${option}`);\n        });\n        this.printLine(`${options.length + 1}. Cancel`);\n        return new Promise((resolve) => {\n          this.rl.question(`Select option (1-${options.length + 1}): `, (answer) => {\n            const choice = parseInt(answer.trim(), 10);\n            if (!isNaN(choice) && choice >= 1 && choice <= options.length + 1) {\n              resolve(choice === options.length + 1 ? -1 : choice - 1);\n            } else {\n              this.printLine('Invalid selection. Please try again.');\n              resolve(this.selectFromList(prompt, options));\n            }\n          });\n        });\n      }\n    }\n    // Save/load system\n    saveGame(slot = \"default\", silent = false) {\n      const saveData = {\n        state: { ...this.state },\n        timestamp: Date.now(),\n        slot: slot\n      };\n      if (this.env === \"browser\") {\n        const saves = JSON.parse(localStorage.getItem(STORAGE_KEY) || \"{}\");\n        saves[slot] = saveData;\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(saves));\n        !silent && this.printLine(`{{green}}Game saved in slot: ${slot}{{color_reset}}`);\n      } else {\n        const saveDir = this.path.join(__dirname, \"saves\");\n        if (!this.fs.existsSync(saveDir)) {\n          this.fs.mkdirSync(saveDir, { recursive: true });\n        }\n        const savePath = this.path.join(saveDir, `save_${slot}.json`);\n        this.fs.writeFileSync(savePath, JSON.stringify(saveData, null, 2));\n        !silent && this.printLine(`{{green}}Game saved in slot: ${slot}{{color_reset}}`);\n      }\n    }\n    loadGame(slot = \"default\") {\n      try {\n        let saveData;\n        if (this.env === \"browser\") {\n          const saves = JSON.parse(localStorage.getItem(STORAGE_KEY) || \"{}\");\n          saveData = saves[slot];\n        } else {\n          const savePath = this.path.join(__dirname, \"saves\", `save_${slot}.json`);\n          if (!this.fs.existsSync(savePath)) {\n            this.printLine(`No save file found in slot: ${slot}`);\n            return false;\n          }\n          saveData = JSON.parse(this.fs.readFileSync(savePath, \"utf8\"));\n        }\n        if (!saveData) {\n          this.printLine(`No save file found in slot: ${slot}`);\n          return false;\n        }\n        this.state = saveData.state;\n        this.printLine(`Game loaded from slot: ${slot}`);\n        this.look();\n        return true;\n      } catch (error) {\n        this.printLine(`Error loading game: ${error.message}`);\n        if (this.config.debug) {\n          console.error(error);\n        }\n        return false;\n      }\n    }\n    deleteSave(slot = \"default\") {\n      try {\n        if (this.env === \"browser\") {\n          const saves = JSON.parse(localStorage.getItem(STORAGE_KEY) || \"{}\");\n          if (saves[slot]) {\n            delete saves[slot];\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(saves));\n            this.printLine(`Save slot ${slot} deleted.`);\n            return true;\n          }\n        } else {\n          const savePath = this.path.join(__dirname, \"saves\", `save_${slot}.json`);\n          if (this.fs.existsSync(savePath)) {\n            this.fs.unlinkSync(savePath);\n            this.printLine(`Save slot ${slot} deleted.`);\n            return true;\n          }\n        }\n        this.printLine(`No save file found in slot: ${slot}`);\n        return false;\n      } catch (error) {\n        this.printLine(`Error deleting save: ${error.message}`);\n        if (this.config.debug) {\n          console.error(error);\n        }\n        return false;\n      }\n    }\n    listSaves() {\n      try {\n        let saves = {};\n        if (this.env === \"browser\") {\n          saves = JSON.parse(localStorage.getItem(STORAGE_KEY) || \"{}\");\n        } else {\n          const saveDir = this.path.join(__dirname, \"saves\");\n          if (this.fs.existsSync(saveDir)) {\n            const files = this.fs.readdirSync(saveDir);\n            files.forEach(file => {\n              if (file.startsWith(\"save_\") && file.endsWith(\".json\")) {\n                const slot = file.replace(\"save_\", \"\").replace(\".json\", \"\");\n                const savePath = this.path.join(saveDir, file);\n                const saveData = JSON.parse(this.fs.readFileSync(savePath, \"utf8\"));\n                saves[slot] = saveData;\n              }\n            });\n          }\n        }\n        if (Object.keys(saves).length === 0) {\n          this.printLine(\"No save files found.\");\n          return;\n        }\n        this.printLine(\"Available saves:\");\n        for (const [slot, data] of Object.entries(saves)) {\n          const date = new Date(data.timestamp);\n          this.printLine(`- ${slot}: ${date.toLocaleString()}`);\n        }\n      } catch (error) {\n        this.printLine(`Error listing saves: ${error.message}`);\n        if (this.config.debug) {\n          console.error(error);\n        }\n      }\n    }\n    // World building methods\n    addRoom(room) {\n      if (!room.id) {\n        room.id = Utils.uuid();\n      }\n      this.world.rooms.set(room.id, room);\n      return room.id;\n    }\n    addItem(item) {\n      if (!item.id) {\n        item.id = Utils.uuid();\n      }\n      item.use = Utils.deserializeFunction(item.use);\n      this.world.items.set(item.id, item);\n      return item.id;\n    }\n    addCharacter(character) {\n      if (!character.id) {\n        character.id = Utils.uuid();\n      }\n      this.world.characters.set(character.id, character);\n      return character.id;\n    }\n    addEvent(event) {\n      if (!event.id) {\n        event.id = Utils.uuid();\n      }\n      this.world.events.set(event.id, event);\n      return event.id;\n    }\n    // Plugin system\n    async loadPlugin(plugin) {\n      try {\n        // Prepare module\n        plugin = await this.prepareModule(plugin);\n        // Register plugin\n        if (plugin.id && !this.plugins.has(plugin.id)) {\n          this.plugins.set(plugin.id, plugin);\n          // Apply plugin components\n          if (plugin.commands) {\n            for (const command of plugin.commands) {\n              this.registerCommand(command);\n            }\n          }\n          if (plugin.rooms) {\n            for (const room of plugin.rooms) {\n              this.addRoom(room);\n            }\n          }\n          if (plugin.items) {\n            for (const item of plugin.items) {\n              this.addItem(item);\n            }\n          }\n          if (plugin.characters) {\n            for (const character of plugin.characters) {\n              this.addCharacter(character);\n            }\n          }\n          if (plugin.events) {\n            for (const event of plugin.events) {\n              this.addEvent(event);\n            }\n          }\n          if (plugin.keybindings) {\n            for (const [key, binding] of Object.entries(plugin.keybindings)) {\n              this.registerKeybinding(key, binding);\n            }\n          }\n          if (plugin.init) {\n            plugin.init(this);\n          }\n          this.printLine(`Plugin loaded: ${plugin.name || plugin.id}`);\n          return true;\n        } else {\n          this.printLine(\"Invalid plugin format: missing id\");\n          return false;\n        }\n      } catch (error) {\n        this.printLine(`Error loading plugin: ${error.message}`);\n        if (this.config.debug) {\n          console.error(error);\n        }\n        return false;\n      }\n    }\n    unloadPlugin(pluginId) {\n      if (this.plugins.has(pluginId)) {\n        const plugin = this.plugins.get(pluginId);\n        // Remove plugin components\n        if (plugin.commands) {\n          for (const name of Object.keys(plugin.commands)) {\n            this.world.commands.delete(name);\n          }\n        }\n        if (plugin.rooms) {\n          for (const room of plugin.rooms) {\n            this.world.rooms.delete(room.id);\n          }\n        }\n        if (plugin.items) {\n          for (const item of plugin.items) {\n            this.world.items.delete(item.id);\n          }\n        }\n        if (plugin.characters) {\n          for (const character of plugin.characters) {\n            this.world.characters.delete(character.id);\n          }\n        }\n        if (plugin.events) {\n          for (const event of plugin.events) {\n            this.world.events.delete(event.id);\n          }\n        }\n        if (plugin.keybindings) {\n          for (const key of Object.keys(plugin.keybindings)) {\n            this.world.keybindings.delete(key);\n          }\n        }\n        this.plugins.delete(pluginId);\n        this.printLine(`Plugin unloaded: ${pluginId}`);\n        return true;\n      } else {\n        this.printLine(`Plugin not found: ${pluginId}`);\n        return false;\n      }\n    }\n    // Theme system\n    async loadTheme(theme) {\n      try {\n        theme = await this.prepareModule(theme);\n        // Apply theme\n        this.theme = { ...DEFAULT_THEME, ...theme };\n        if (this.env === \"browser\") {\n          // Update CSS variables\n          for (const [property, value] of Object.entries(this.theme)) {\n            document.documentElement.style.setProperty(property, value);\n          }\n          // Update terminal styles\n          this.terminalElement.style.backgroundColor = this.theme[\"--lore-bg-color\"];\n          this.terminalElement.style.color = this.theme[\"--lore-text-color\"];\n          this.terminalElement.style.fontFamily = this.theme[\"--lore-font-family\"];\n          this.terminalElement.style.fontSize = this.theme[\"--lore-font-size\"];\n          this.promptElement.style.color = this.theme[\"--lore-prompt-color\"];\n          this.inputElement.style.color = this.theme[\"--lore-input-color\"];\n          if (this.theme[\"--lore-prompt-content\"]) {\n            this.updatePrompt(this.theme[\"--lore-prompt-content\"]);\n          }\n        } else {\n          if (this.theme[\"--lore-prompt-content\"]) {\n            this.updatePrompt(this.theme[\"--lore-prompt-content\"]);\n          }\n        }\n        return true;\n      } catch (error) {\n        this.printLine(`Error loading theme: ${error.message}`);\n        if (this.config.debug) {\n          console.error(error);\n        }\n        return false;\n      }\n    }\n    // Prepare modules to be used\n    async prepareModule(content) {\n      if (typeof content !== \"string\") return content;\n\n      // If content is a URL or looks like a path, fetch it\n      if (Utils.isURL(content) || content.includes('/') || content.includes('\\\\')) {\n        if (content.endsWith(\".js\")) {\n          try {\n            if (this.env === \"browser\") {\n              content = await Utils.loadModule(content);\n            } else {\n              content = require(this.path.resolve(process.cwd(), content));\n            }\n            return content; // Return early if we loaded a JS module\n          } catch (error) {\n            this.printLine(`{{red}}Couldn't prepare module\\n${error.message}`);\n            return {};\n          }\n        } else if (!content.trim().startsWith('{') && !content.trim().startsWith('[')) {\n          this.printLine(`{{red}}Module loaded from URL must be a JavaScript (.js) file{{color_reset}}`);\n          return {};\n        }\n      }\n\n      // Only attempt to parse as JSON if it looks like JSON\n      if (typeof content === \"string\" && (content.trim().startsWith('{') || content.trim().startsWith('['))) {\n        try {\n          content = JSON.parse(content);\n        } catch (error) {\n          this.printLine(`{{red}}Error parsing JSON module: ${error.message}{{color_reset}}`);\n          return {};\n        }\n      }\n      return content;\n    }\n    // Command registration\n    printHelp(commandName) {\n      if (!commandName) {\n        this.printLine(\"{{bold}}Available commands:{{font_reset}}\");\n        const commands = Array.from(this.world.commands)\n          .map(command => command[1])\n          .sort((a, b) => a.weight - b.weight)\n          .filter(command => command.help && command.weight != -1);\n        commands.forEach(command => {\n          const name = command.display || command.name;\n          const aliases = command.aliases && command.aliases.length ? \", \" + command.aliases.join(', ') : \"\";\n          const help = command.help;\n          this.printLine(`  {{green}}${name}{{color_reset}}{{green}}${aliases}{{color_reset}} - ${help}`);\n        });\n      } else {\n        if (!this.world.commands.has(commandName) && this.world.aliases.has(commandName)) {\n          commandName = this.world.aliases.get(commandName);\n        }\n        const command = this.world.commands.get(commandName);\n        if (!command) {\n          this.printLine(\"\");\n          this.printLine(`Unknown command: ${commandName}. Type 'help' for available commands.`);\n        } else {\n          const aliases = command.aliases && command.aliases.length ? \", \" + command.aliases.join(', ') : \"\";\n          this.printLine(`{{green}}${command.name}${aliases}{{color_reset}`);\n          this.printLine(\"Usage:\");\n          this.printLine(`{{green}}${command.display || command.name}{{color_reset}}`);\n          if (command.purpose) {\n            this.printLine(`Use it to ${command.purpose}.`);\n          }\n        }\n      }\n    }\n    registerCommand(command) {\n      if (!command || !command.name) return;\n      this.world.commands.set(command.name.toLowerCase(), {\n        name: \"foo\",\n        aliases: [],\n        fn: () => {},\n        help: \"\",\n        weight: null,\n        purpose: null,\n        ...command\n      });\n      if (command.aliases) {\n        command.aliases.forEach(alias => {\n          this.world.aliases.set(alias, command.name.toLowerCase());\n        })\n      }\n    }\n    registerKeybinding(key, action) {\n      this.world.keybindings.set(key, action);\n    }\n    registerDefaultCommands() {\n      // Help command\n      this.registerCommand({\n        name: \"help\",\n        aliases: [\"h\", \"?\"],\n        fn: (args, engine) => engine.printHelp(args[0]),\n        help: \"Show this help\",\n        purpose: \"see available commands\",\n        weight: 1000\n      });\n      // Look command\n      this.registerCommand({\n        name: \"look\",\n        aliases: [\"l\", \"see\", \"examine\", \"inspect\"],\n        fn: (args, engine) => {\n          if (args.length === 0) {\n            // Default look around behavior\n            engine.look();\n            return;\n          }\n          // Look at specific item\n          const target = args.join(\" \").toLowerCase();\n          engine.lookAtItem(target);\n        },\n        help: \"Look around or examine a specific item\",\n        purpose: \"look around\",\n        weight: 1\n      });\n      // Movement commands\n      this.registerCommand({\n        name: \"go\",\n        display: \"go [dir]\",\n        fn: (args, engine) => {\n          if (args.length === 0) {\n            const currentRoom = engine.world.rooms.get(engine.state.currentRoom);\n            if (!currentRoom || !currentRoom.exits || !JSON.stringify(currentRoom.exits) == \"{}\") {\n              engine.printLine(\"Go where?\");\n            } else {\n              engine.printRoomExits(currentRoom);\n            }\n            return;\n          }\n          engine.move(args[0]);\n        },\n        help: \"Move in a direction\",\n        purpose: \"move in a direction\",\n        weight: 2\n      })\n      // Direction shortcuts\n      const directions = [\"north\", \"south\", \"east\", \"west\", \"northeast\", \"northwest\", \"southeast\", \"southwest\", \"up\", \"down\", \"in\", \"out\"];\n      const aliases = [\"n\", \"s\", \"e\", \"w\", \"ne\", \"nw\", \"se\", \"sw\", \"u\", \"d\", \"i\", \"o\"];\n      for (let i = 0; i < directions.length; i++) {\n        const dir = directions[i];\n        const alias = aliases[i];\n        this.registerCommand({\n          name: dir,\n          aliases: [alias],\n          fn: (args, engine) => engine.move(dir),\n          help: null,\n          purpose: `go ${dir}`,\n          weight: -1\n        });\n      }\n      // Take command\n      this.registerCommand({\n        name: \"take\",\n        display: \"take [item]\",\n        fn: (args, engine) => {\n          if (args.length === 0) {\n            const room = engine.world.rooms.get(engine.state.currentRoom);\n            if (!room || !room.items || room.items.length === 0) {\n              engine.printLine(\"Take what? There's nothing here to take.\");\n              return;\n            }\n            engine.printLine(\"What would you like to take?\");\n            const itemList = room.items\n              .map(id => {\n                const item = engine.world.items.get(id);\n                return item ? `- ${item.name}${item.aliases ? ` (also: ${item.aliases.join(', ')})` : ''}` : \"unknown item\";\n              })\n              .join(\"\\n\");\n            engine.printLine(itemList);\n            return;\n          }\n          const room = engine.world.rooms.get(engine.state.currentRoom);\n          if (!room || !room.items) {\n            engine.printLine(\"There's nothing to take here.\");\n            return;\n          }\n          // Find item by name or alias\n          const itemName = args.join(\" \").toLowerCase();\n          let itemId = null;\n          for (const id of room.items) {\n            const item = engine.world.items.get(id);\n            if (item) {\n              // Check main name\n              if (item.name.toLowerCase().includes(itemName)) {\n                itemId = id;\n                break;\n              }\n              // Check aliases\n              if (item.aliases) {\n                for (const alias of item.aliases) {\n                  if (alias.toLowerCase().includes(itemName)) {\n                    itemId = id;\n                    break;\n                  }\n                }\n              }\n              if (itemId) break;\n            }\n          }\n          if (itemId) {\n            engine.takeItem(itemId);\n          } else {\n            engine.printLine(\"You don't see that here.\");\n          }\n        },\n        help: \"Take an item\",\n        purpose: \"take something\",\n        weight: 3\n      });\n      // Drop command\n      this.registerCommand({\n        name: \"drop\",\n        display: \"drop [item]\",\n        fn: (args, engine) => {\n          if (args.length === 0) {\n            engine.printLine(\"Drop what?\");\n            return;\n          }\n          // Find item by name in inventory\n          const itemName = args.join(\" \").toLowerCase();\n          let itemId = null;\n          for (const id of engine.state.inventory) {\n            const item = engine.world.items.get(id);\n            if (item && item.name.toLowerCase().includes(itemName)) {\n              itemId = id;\n              break;\n            }\n          }\n          if (itemId) {\n            engine.dropItem(itemId);\n          } else {\n            engine.printLine(\"You don't have that item.\");\n          }\n        },\n        help: \"Drop an item\",\n        purpose: \"drop something you don't need anymore\",\n        weight: 4\n      });\n      // Inventory command\n      this.registerCommand({\n        name: \"inventory\",\n        aliases: [\"i\"],\n        fn: (args, engine) => {\n          if (engine.state.inventory.length === 0) {\n            engine.printLine(\"You are carrying nothing.\");\n            return;\n          }\n          engine.printLine(\"{{bold}}You are carrying:{{font_reset}}\");\n          for (const itemId of engine.state.inventory) {\n            const item = engine.world.items.get(itemId);\n            if (item) {\n              engine.printLine(`- ${item.name}`);\n            }\n          }\n        },\n        help: \"Show your inventory\",\n        purpose: \"show items you have\",\n        weight: 5\n      });\n      // Use command\n      this.registerCommand({\n        name: \"use\",\n        display: \"use [item]\",\n        fn: (args, engine) => {\n          if (args.length === 0) {\n            engine.printLine(\"Use what?\");\n            return;\n          }\n          const itemName = args.join(\" \").toLowerCase();\n          // First check inventory\n          let itemId = null;\n          for (const id of engine.state.inventory) {\n            const item = engine.world.items.get(id);\n            if (item && (\n              item.name.toLowerCase().includes(itemName) ||\n              (item.aliases && item.aliases.some(alias => alias.toLowerCase().includes(itemName)))\n            )) {\n              itemId = id;\n              break;\n            }\n          }\n          if (itemId) {\n            // Use item from inventory\n            engine.useItem(itemId);\n          } else {\n            // Try to use untakeable item in the room\n            engine.useUntakeableItem(itemName);\n          }\n        },\n        help: \"Use an item from inventory or in the environment\",\n        purpose: \"use something you have close\",\n        weight: 6\n      });\n      // Say command\n      this.registerCommand({\n        name: \"say\",\n        display: \"say [...]\",\n        fn: (args, engine) => {\n          if (args.length === 0) {\n            engine.printLine(\"You don't say\");\n            return;\n          }\n          const line = args.join(\" \");\n          engine.printLine(`You say:{{n}} - ${line}`);\n          // Trigger character reactions\n          const room = engine.world.rooms.get(engine.state.currentRoom);\n          if (room && room.characters) {\n            let interrupt = false;\n            room.characters.forEach(charId => {\n              const character = engine.world.characters.get(charId);\n              if (character && character.onSay && !interrupt) {\n                interrupt = character.onSay(line, engine.state, engine) ? true : false;\n              }\n            });\n          }\n        },\n        help: \"Say something\",\n        purpose: \"say something\",\n        weight: 7\n      });\n      // Talk command\n      this.registerCommand({\n        name: \"talk\",\n        display: \"talk [character] about [topic]\",\n        fn: (args, engine) => {\n          if (args.length === 0) {\n            const room = engine.world.rooms.get(engine.state.currentRoom);\n            if (!room || !room.characters || room.characters.length === 0) {\n              engine.printLine(\"Talk to whom? There's no one here.\");\n              return;\n            }\n            engine.printLine(\"Who would you like to talk to?\");\n            const charList = room.characters\n              .map(id => {\n                const character = engine.world.characters.get(id);\n                if (!character) return \"unknown character\";\n                let display = `- ${character.name}`;\n                if (character.aliases) {\n                  display += ` (also: ${character.aliases.join(', ')})`;\n                }\n                if (character.genre && room.characters.length === 1) {\n                  display += ` or use \"talk ${character.genre === \"male\" ? \"him\" : \"her\"}\"`;\n                }\n                return display;\n              })\n              .join(\"\\n\");\n            engine.printLine(charList);\n            return;\n          }\n          const room = engine.world.rooms.get(engine.state.currentRoom);\n          if (!room || !room.characters) {\n            engine.printLine(\"There's no one here to talk to.\");\n            return;\n          }\n          // Parse command for \"about\" keyword\n          const aboutIndex = args.findIndex(arg => arg === \"about\");\n          let topic = null;\n          let charIdentifier;\n          if (aboutIndex !== -1) {\n            charIdentifier = args.slice(0, aboutIndex).join(\" \").toLowerCase();\n            topic = args.slice(aboutIndex + 1).join(\" \").toLowerCase();\n          } else {\n            charIdentifier = args.join(\" \").toLowerCase();\n          }\n          // Find character by name, alias, or genre pronoun\n          let characterId = null;\n          let character = null;\n          for (const id of room.characters) {\n            const char = engine.world.characters.get(id);\n            if (!char) continue;\n            // Check main name\n            if (char.name.toLowerCase().includes(charIdentifier)) {\n              characterId = id;\n              character = char;\n              break;\n            }\n            // Check aliases\n            if (char.aliases) {\n              for (const alias of char.aliases) {\n                if (alias.toLowerCase().includes(charIdentifier)) {\n                  characterId = id;\n                  character = char;\n                  break;\n                }\n              }\n              if (characterId) break;\n            }\n            // Check genre pronoun (only if single character in room)\n            if (char.genre && room.characters.length === 1) {\n              if ((char.genre === 'female' && (charIdentifier === 'her' || charIdentifier === 'she')) ||\n                  (char.genre === 'male' && (charIdentifier === 'him' || charIdentifier === 'he'))) {\n                characterId = id;\n                character = char;\n                break;\n              }\n            }\n          }\n          if (!characterId) {\n            engine.printLine(\"You don't see that person here.\");\n            return;\n          }\n          // Handle topic-based conversation\n          if (topic && character.topics) {\n            let foundTopic = false;\n            for (const [topicKey, topicData] of Object.entries(character.topics)) {\n              if (topicKey.toLowerCase().includes(topic) || \n                  (topicData.aliases && topicData.aliases.some(alias => alias.toLowerCase().includes(topic)))) {\n                if (topicData.condition && !topicData.condition(engine.state)) {\n                  engine.printLine(topicData.blockedMessage || `${character.name} doesn't want to talk about that right now.`);\n                } else {\n                  topicData.dialog(engine.state, engine);\n                  // Update flags if specified\n                  if (topicData.setFlag) {\n                    engine.state.flags[topicData.setFlag] = true;\n                  }\n                }\n                foundTopic = true;\n                break;\n              }\n            }\n            if (!foundTopic) {\n              engine.printLine(`${character.shortName || character.name} doesn't seem to know anything about \"${topic}\".`);\n            }\n          } else {\n            // Standard talk interaction\n            if (character.talk) {\n              character.talk(engine.state, engine);\n            } else {\n              engine.printLine(`${character.shortName || character.name} has nothing to say to you right now.`);\n            }\n          }\n        },\n        help: \"Talk to someone or ask about a specific topic\",\n        purpose: \"talk to someone or ask about a specific topic\",\n        weight: 8\n      });\n      // Save command\n      this.registerCommand({\n        name: \"save\", \n        display: \"save [slot]\",\n        fn: (args, engine) => {\n          const slot = args.length > 0 ? args[0] : \"default\";\n          engine.saveGame(slot);\n        },\n        help: \"Save the game\",\n        purpose: \"save the game\",\n        weight: 9\n      });\n      // Load command\n      this.registerCommand({\n        name: \"load\",\n        display: \"load [slot]\",\n        fn: (args, engine) => {\n          const slot = args.length > 0 ? args[0] : \"default\";\n          engine.loadGame(slot);\n        },\n        help: \"Load a saved game\",\n        purpose: \"load a saved game\",\n        weight: 10\n      });\n      // Restart command\n      this.registerCommand({\n        name: \"restart\",\n        fn: () => this.restartGame(),\n        help: \"Restart the game\",\n        purpose: \"restart the game\",\n        weight: 11\n      });\n      // Quit command\n      this.registerCommand({\n        name: \"quit\",\n        aliases: [\"exit\"],\n        fn: (args, engine) => {\n          engine.printLine(\"{{green}}Goodbye!{{color_reset}}\");\n          if (engine.env === \"node\") {\n            engine.rl.close();\n          } else {\n            // In browser, we can't really quit, so just clear and reset\n            engine.stopAllAnimations();\n            engine.state = {\n              currentRoom: null,\n              inventory: [],\n              flags: {},\n              variables: {},\n              history: [],\n              gameTime: 0\n            };\n            engine.clearScreen();\n          }\n        },\n        help: \"Quit the game\",\n        purpose: \"finish playing\",\n        weight: 999\n      });\n    }\n    // Novel loading\n    async loadNovel(novel) {\n      try {\n        novel = await this.prepareModule(novel);\n        // Clear existing world\n        this.world.rooms.clear();\n        this.world.items.clear();\n        this.world.characters.clear();\n        this.world.events.clear();\n        // Keep commands and keybindings\n        const commands = new Map(this.world.commands);\n        const keybindings = new Map(this.world.keybindings);\n        this.world.commands = commands;\n        this.world.keybindings = keybindings;\n        // Load novel data\n        if (novel.rooms) {\n          for (const room of novel.rooms) {\n            this.addRoom(room);\n          }\n        }\n        if (novel.items) {\n          for (const item of novel.items) {\n            this.addItem(item);\n          }\n        }\n        if (novel.characters) {\n          for (const character of novel.characters) {\n            this.addCharacter(character);\n          }\n        }\n        if (novel.events) {\n          for (const event of novel.events) {\n            this.addEvent(event);\n          }\n        }\n        if (novel.startRoom) {\n          this.state.currentRoom = novel.startRoom;\n        } else {\n          this.state.currentRoom = null;\n        }\n        if (this.config.clearScreenOnNovelLoad) {\n          this.clearScreen();\n        }\n        this.startGame(this.state.currentRoom);\n        return true;\n      } catch (error) {\n        this.printLine(`Error loading novel: ${error.message}`);\n        if (this.config.debug) {\n          console.error(error);\n        }\n        return false;\n      }\n    }\n  }\n  \n  return {\n    ANSI_COLORS,\n    ANSI_STYLES,\n    VERSION,\n    STORAGE_KEY,\n    DEFAULT_PROMPT,\n    DEFAULT_THEME,\n    DEFAULT_CONFIG,\n    Game,\n    Utils\n  };\n});"
        }
    ]
}